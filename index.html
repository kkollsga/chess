<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Chess">
    <link rel="apple-touch-icon" href="/api/placeholder/180/180">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            min-height: 100vh;
            min-height: -webkit-fill-available;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .piece {
            font-family: "SF Pro", ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.3));
            text-shadow: 2px 0px 5px rgba(0, 0, 0, 0.3);
            font-size: clamp(1rem, min(4vw, 4vh), 3rem);
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .piece[data-color="black"] {
            color: #000000;
        }

        .piece[data-color="white"] {
            color: #ffffff;
            text-shadow: -1px -1px 0 #000, 
                        1px -1px 0 #000, 
                        -1px 1px 0 #000, 
                        1px 1px 0 #000,
                        2px 2px 3px rgba(0, 0, 0, 0.3);
        }

        .piece:active { 
            cursor: grabbing;
        }

        .move-number {
            text-shadow: -1px -1px 0 #000, 
                        1px -1px 0 #000, 
                        -1px 1px 0 #000, 
                        1px 1px 0 #000,
                        2px 2px 3px rgba(0, 0, 0, 0.3);
        }

        @keyframes slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slide-up-in {
            from {
                transform: translate(-50%, 100%);
            }
            to {
                transform: translate(-50%, 0);
            }
        }

        @keyframes slide-down-out {
            from {
                transform: translate(-50%, 0);
            }
            to {
                transform: translate(-50%, 100%);
            }
        }

        @keyframes slide-down-in {
            from {
                transform: translate(-50%, -100%);
            }
            to {
                transform: translate(-50%, 0);
            }
        }

        @keyframes slide-up-out {
            from {
                transform: translate(-50%, 0);
            }
            to {
                transform: translate(-50%, -100%);
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
    <div class="game-container flex flex-col gap-4 items-center w-full h-full max-w-[1400px] min-w-[320px] mx-auto px-4">
        <!-- Black player row -->
        <div id="black-indicator" class="
            px-8 py-3
            rounded-xl text-lg font-bold
            transition-all duration-200 text-gray-400
        ">Player Black</div>

        <!-- Game area row with 3 columns -->
        <div class="flex w-full gap-1 flex-grow items-stretch justify-center min-h-[400px] ">
            <!-- Left column - black captures -->
            <div class="flex flex-col items-center pt-1 w-[10%] min-w-[48px]">
                <div id="black-captures" class="side-board w-full flex flex-col items-end">
                    <div class="flex-grow"></div>
                    <div class="pieces-container grid grid-cols-2 grid-rows-[8] gap-1 auto-rows-fr w-[60%] aspect-[1/4.5] leading-none text-center"></div>
                </div>
                <div class="flex-grow"></div>
            </div>

            <!-- Center column - main board -->
            <div class="flex items-center justify-center">
                <div class="w-full aspect-square">
                    <div id="board" class="w-full h-full grid grid-cols-8 border-2 border-gray-800 bg-white shadow-xl rounded-sm overflow-hidden"></div>
                </div>
            </div>

            <!-- Right column - white captures -->
            <div class="flex flex-col items-center pb-2 w-[10%] min-w-[48px]">
                <div class="flex-grow"></div>
                <div id="white-captures" class="side-board w-full flex flex-col items-start">
                    <div class="pieces-container grid grid-cols-2 grid-rows-[8] gap-1 auto-rows-fr w-[60%] aspect-[1/4.5] leading-none text-center"></div>
                </div>
            </div>
        </div>

        <!-- White player row -->
        <div id="white-indicator" class="
            px-8 py-3
            rounded-xl text-lg font-bold
            transition-all duration-200 text-gray-400
        ">Player White</div>

        <!-- Navigation row -->
        <div id="navigation" class="flex items-center justify-center gap-6 pb-4">
            <button class="nav-back w-10 h-10 rounded-full flex items-center justify-center text-gray-800 hover:bg-gray-100 transition-colors disabled:opacity-50 disabled:hover:bg-transparent">
                <div class="text-2xl rotate-45">↙</div>
            </button>
            <div class="move-number font-bold text-gray-100 text-lg"></div>
            <button class="nav-forward w-10 h-10 rounded-full flex items-center justify-center text-gray-800 hover:bg-gray-100 transition-colors disabled:opacity-50 disabled:hover:bg-transparent">
                <div class="text-2xl rotate-45">↗</div>
            </button>
        </div>
    </div>

    <!-- Add this right after the game-container div -->
    <div id="burger-menu" class="fixed top-4 left-4 z-50">
        <button 
            id="menu-button"
            class="p-2 rounded-lg bg-white/90 shadow-lg hover:bg-gray-50 transition-colors"
        >
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="4" x2="20" y1="12" y2="12"/>
                <line x1="4" x2="20" y1="6" y2="6"/>
                <line x1="4" x2="20" y1="18" y2="18"/>
            </svg>
        </button>
        
        <div id="menu-dropdown" class="hidden absolute left-0 mt-2 w-48 bg-white rounded-lg shadow-xl">
            <button 
                id="import-fen-button"
                class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-blue-50 rounded-lg"
            >
                Import FEN
            </button>
            <button 
                id="import-button"
                class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-blue-50 rounded-lg"
            >
                Import PGN
            </button>  
            <button 
                id="new-game-button"
                class="w-full text-left px-4 py-2 text-sm text-green-700 hover:bg-green-50 rounded-lg"
            >
                New Game
            </button>  
        </div>
    </div>

    <!-- Modal for PGN import -->
    <div id="pgn-modal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 w-full max-w-2xl mx-4 shadow-2xl">
            <h2 class="text-xl font-bold mb-4">Import PGN</h2>
            
            <textarea
                id="pgn-input"
                class="w-full h-64 p-4 border rounded-lg font-mono text-sm mb-4"
                placeholder="Paste PGN here..."
            ></textarea>
            
            <div class="flex justify-end gap-2">
                <button 
                    id="cancel-import"
                    class="px-4 py-2 rounded-lg text-gray-600 hover:bg-gray-100 transition-colors"
                >
                    Cancel
                </button>
                <button 
                    id="confirm-import"
                    class="px-4 py-2 rounded-lg bg-gray-800 text-white hover:bg-gray-700 transition-colors"
                >
                    Import
                </button>
            </div>
        </div>
    </div>

    <!-- Add this modal after the pgn-modal -->
    <div id="fen-modal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 w-full max-w-2xl mx-4 shadow-2xl">
            <h2 class="text-xl font-bold mb-4">Import FEN</h2>
            
            <input
                id="fen-input"
                class="w-full p-4 border rounded-lg font-mono text-sm mb-4"
                placeholder="Enter FEN here..."
            />
            
            <div class="flex justify-end gap-2">
                <button 
                    id="cancel-fen-import"
                    class="px-4 py-2 rounded-lg text-gray-600 hover:bg-gray-100 transition-colors"
                >
                    Cancel
                </button>
                <button 
                    id="confirm-fen-import"
                    class="px-4 py-2 rounded-lg bg-gray-800 text-white hover:bg-gray-700 transition-colors"
                >
                    Import
                </button>
            </div>
        </div>
    </div>

<script>
class Notification {
    static formatStack(stack) {
        if (!stack) return 'No stack trace available';
        return stack
            .split('\n')
            .map(line => line.trim())
            .join('\n    ');  // Indent stack lines for readability
    }

    static show(error, type = 'error') {
        const isErrorObject = error instanceof Error;
        const userMessage = isErrorObject ? error.message : error;
        
        // Enhanced console logging with grouping and formatting
        if (type === 'error') {
            if (isErrorObject) {
                console.error(this.formatStack(error.stack));
            } else {
                console.error('Error:', error);
            }
        } else if (type === 'warning') {
            console.warn('Warning:', error);
        } else {
            console.log('Info:', error);
        }

        const notification = document.createElement('div');
        notification.className = `
            fixed top-4 right-4 p-4 rounded-lg text-white max-w-sm
            ${type === 'error' ? 'bg-red-500' : 
                type === 'warning' ? 'bg-yellow-500' : 
                'bg-green-500'}
            shadow-lg
            animate-[slide-in_0.3s_ease-out]
        `;
        
        notification.innerHTML = `
            <div class="flex items-center gap-2 font-medium">
                ${userMessage}
            </div>
        `;

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.classList.add('opacity-0', 'translate-x-full', 'transition-all', 'duration-300', 'ease-in');
            setTimeout(() => notification.remove(), 300);
        }, 5000);
    }

    static showBoardNotification(text, side = null, ms = null) {
        // Log board notifications for debugging
        console.log('Board Notification:', text);
        
        const boardContainer = document.querySelector('.board-container');
        const board = document.querySelector('#board');
        
        if (!board.classList.contains('z-20')) {
            board.classList.add('z-20');
        }
        
        const existingTop = boardContainer.querySelector('[data-board-notification="top"]');
        const existingBottom = boardContainer.querySelector('[data-board-notification="bottom"]');
        
        if (existingTop) {
            existingTop.classList.remove('animate-[slide-up-in_0.3s_ease-out]');
            existingTop.classList.add('animate-[slide-down-out_0.3s_ease-out]');
            setTimeout(() => existingTop.remove(), 300);
        }
        if (existingBottom) {
            existingBottom.classList.remove('animate-[slide-down-in_0.3s_ease-out]');
            existingBottom.classList.add('animate-[slide-up-out_0.3s_ease-out]');
            setTimeout(() => existingBottom.remove(), 300);
        }
        
        if (side) {
            const notification = document.createElement('div');
            
            const baseClasses = `
                absolute left-1/2 -translate-x-1/2 px-6 py-2 
                rounded-xl text-sm font-bold shadow-xl z-0
            `;
            
            const sideSpecificClasses = {
                'top': `bg-black/90 text-white -top-7 animate-[slide-up-in_0.3s_ease-out]`,
                'bottom': `bg-white/90 text-gray-800 bottom-[60px] animate-[slide-down-in_0.3s_ease-out]`
            };
            
            notification.className = `${baseClasses} ${sideSpecificClasses[side]}`;
            notification.innerHTML = text;
            notification.dataset.boardNotification = side;
            
            boardContainer.insertBefore(notification, board);
        }
    }
}

class Piece {
    static PIECES = {
        'K': '♚',
        'Q': '♛',
        'R': '♜',
        'B': '♝',
        'N': '♞',
        'P': '♟',
        'k': '♚',
        'q': '♛',
        'r': '♜',
        'b': '♝',
        'n': '♞',
        'p': '♟'
    };

    static getSymbol(fen) {
        return this.PIECES[fen];
    }

    static getColor(fen) {
        return fen === fen.toUpperCase() ? 'white' : 'black';
    }

    static isWhite(fen) {
        return fen === fen.toUpperCase();
    }

    static isBlack(fen) {
        return fen === fen.toLowerCase();
    }
}

class FenParser {
    static VALID_PIECES = new Set(['K', 'Q', 'R', 'B', 'N', 'P', 'k', 'q', 'r', 'b', 'n', 'p']);
    static VALID_COLORS = new Set(['w', 'b']);
    static VALID_CASTLING_CHARS = new Set(['K', 'Q', 'k', 'q', '-']);

    static STANDARD_PIECE_COUNTS = {
        'K': 1, 'Q': 1, 'R': 2, 'B': 2, 'N': 2, 'P': 8,  // White pieces
        'k': 1, 'q': 1, 'r': 2, 'b': 2, 'n': 2, 'p': 8   // Black pieces
    };

    static getDefaultFen() {
        return 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';
    }

    static countPieces(board) {
        const pieceCounts = {};
        for (const piece of this.VALID_PIECES) {
            pieceCounts[piece] = 0;
        }

        for (const row of board) {
            for (const piece of row) {
                if (piece !== null) {
                    pieceCounts[piece]++;
                }
            }
        }

        return pieceCounts;
    }

    static getPiecesAtSquares(squares, fen) {
        // Parse FEN to get the board array
        const { board } = this.parseFen(fen);
        
        // Convert algebraic notation to board indices and get pieces
        return squares.map(square => {
            const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = 8 - parseInt(square.charAt(1));
            return board[rank][file] || null; // Return null for empty squares
        });
    }
    
    static validatePosition(position) {
        // Split FEN into its components if a full FEN string is provided
        const boardPosition = position.split(' ')[0];

        // Check if position exists and is string
        if (!boardPosition || typeof boardPosition !== 'string') {
            throw new Error('Invalid FEN: Position string is required');
        }

        const rows = boardPosition.split('/');
        if (rows.length !== 8) {
            throw new Error(`Invalid FEN: Position must have 8 ranks. '${rows.length} ranks'`);
        }

        for (const row of rows) {
            let squareCount = 0;
            for (const char of row) {
                if (/\d/.test(char)) {
                    squareCount += parseInt(char);
                } else if (this.VALID_PIECES.has(char)) {
                    squareCount++;
                } else {
                    throw new Error(`Invalid FEN: Invalid piece character '${char}'`);
                }
            }
            if (squareCount !== 8) {
                throw new Error(`Invalid FEN: Each rank must have exactly 8 squares. '${row}'`);
            }
        }

        return true;
    }

    static validateGameState(gameState) {
        // Validate active color
        if (!this.VALID_COLORS.has(gameState.activeColor)) {
            throw new Error(`Invalid FEN: Active color must be 'w' or 'b', got '${gameState.activeColor}'`);
        }

        // Validate castling
        if (gameState.castling !== '-') {
            const castlingChars = new Set(gameState.castling.split(''));
            for (const char of castlingChars) {
                if (!this.VALID_CASTLING_CHARS.has(char)) {
                    throw new Error(`Invalid FEN: Invalid castling character '${char}'`);
                }
            }
        }

        // Validate en passant - only rank 3 or 6 are valid per official spec
        if (gameState.enPassant !== '-') {
            const validSquares = /^[a-h][36]$/;
            if (!validSquares.test(gameState.enPassant)) {
                throw new Error(`Invalid FEN: Invalid en passant square '${gameState.enPassant}'`);
            }
        }

        // Validate move numbers
        if (!/^\d+$/.test(gameState.halfmove) || parseInt(gameState.halfmove) < 0) {
            throw new Error(`Invalid FEN: Invalid halfmove clock '${gameState.halfmove}'`);
        }
        if (!/^\d+$/.test(gameState.fullmove) || parseInt(gameState.fullmove) < 1) {
            throw new Error(`Invalid FEN: Invalid fullmove number '${gameState.fullmove}'`);
        }

        return true;
    }

    static validatePieceCounts(pieceCounts) {
        const warnings = [];
        
        // Check for exactly one king of each color
        if (pieceCounts['K'] !== 1) warnings.push(`Invalid white king count: ${pieceCounts['K']}`);
        if (pieceCounts['k'] !== 1) warnings.push(`Invalid black king count: ${pieceCounts['k']}`);
        
        // Check pieces against maximum possible counts (accounting for promotions)
        const whitePawns = pieceCounts['P'];
        const blackPawns = pieceCounts['p'];
        const whitePromotions = Math.max(0, 8 - whitePawns);
        const blackPromotions = Math.max(0, 8 - blackPawns);

        // Validate non-pawn piece counts considering possible promotions
        const validatePiece = (piece, standardCount, promotions) => {
            const count = pieceCounts[piece];
            const maxCount = standardCount + promotions;
            if (count > maxCount) {
                warnings.push(`Too many ${piece}'s: ${count}/${standardCount} (max ${maxCount} with promotions)`);
            }
        };

        // Check white pieces
        validatePiece('Q', 1, whitePromotions);
        validatePiece('R', 2, whitePromotions);
        validatePiece('B', 2, whitePromotions);
        validatePiece('N', 2, whitePromotions);

        // Check black pieces
        validatePiece('q', 1, blackPromotions);
        validatePiece('r', 2, blackPromotions);
        validatePiece('b', 2, blackPromotions);
        validatePiece('n', 2, blackPromotions);

        return warnings;
    }

    static calculateCapturedPieces(pieceCounts) {
        const capturedPieces = [];
        const pieceOrder = ['q', 'r', 'b', 'n', 'p', 'Q', 'R', 'B', 'N', 'P'];

        // Simplified helper that just returns missing pieces
        const getMissingPieces = (piece, standardCount) => {
            const currentCount = pieceCounts[piece];
            return Math.max(0, standardCount - currentCount);
        };

        // Calculate captured pieces based on missing pieces
        for (const piece of pieceOrder) {
            const standardCount = this.STANDARD_PIECE_COUNTS[piece];
            const missing = getMissingPieces(piece, standardCount);
            
            // Add missing pieces to the captured array
            for (let i = 0; i < missing; i++) {
                capturedPieces.push(piece);
            }
        }

        return capturedPieces;
    }

    static isValidSetup(pieceCounts) {
        // Must have exactly one king of each color
        if (pieceCounts['K'] !== 1 || pieceCounts['k'] !== 1) {
            return false;
        }

        // Helper to check if a piece count is valid considering promotions
        const isValidCount = (piece, standardCount) => {
            const count = pieceCounts[piece];
            const isWhite = piece === piece.toUpperCase();
            
            // For pawns, just check they don't exceed starting count
            if (piece === 'P' || piece === 'p') {
                return count <= 8;
            }

            // For other pieces, consider possible promotions
            const pawns = pieceCounts[isWhite ? 'P' : 'p'];
            const promotions = Math.max(0, 8 - pawns);
            return count <= standardCount + promotions;
        };

        // Check all pieces are within valid limits
        return Object.entries(this.STANDARD_PIECE_COUNTS).every(([piece, standardCount]) => 
            isValidCount(piece, standardCount)
        );
    }

    static parseFen(fen) {
        try {
            const parts = fen.split(' ');
            const position = parts[0];

            // Validate position part
            this.validatePosition(position);
            
            // Create board from position
            const rows = position.split('/');
            const board = [];

            for (const row of rows) {
                const boardRow = [];
                for (const char of row) {
                    if (/\d/.test(char)) {
                        const emptySquares = parseInt(char);
                        boardRow.push(...Array(emptySquares).fill(null));
                    } else {
                        boardRow.push(char);
                    }
                }
                board.push(boardRow);
            }

            // Count pieces and validate setup
            const pieceCounts = this.countPieces(board);
            const warnings = this.validatePieceCounts(pieceCounts);
            const isValidSetup = this.isValidSetup(pieceCounts);
            const capturedPieces = isValidSetup ? this.calculateCapturedPieces(pieceCounts) : [];

            // Parse and validate additional settings if provided
            const gameState = {
                activeColor: parts[1] || 'w',
                castling: parts[2] || 'KQkq',
                enPassant: parts[3] || '-',
                halfmove: parts[4] || '0',
                fullmove: parts[5] || '1',
                isValidSetup,
                warnings,
                capturedPieces
            };

            this.validateGameState(gameState);

            // Show warnings if any exist
            if (warnings.length > 0) {
                Notification.show(
                    'Warning: Non-standard piece configuration\n' + 
                    warnings.join('\n'),
                    'warning'
                );
            }

            return { board, gameState };

        } catch (error) {
            Notification.show(error, 'error');
            return this.parseFen(this.getDefaultFen());
        }
    }

    static generateFen(board, gameState = {}) {
        const {
            activeColor = 'w',
            castling = 'KQkq',
            enPassant = '-',
            halfmove = '0',
            fullmove = '1'
        } = gameState;
        const rows = board.map(row => {
            let emptyCount = 0;
            let fenRow = '';

            for (const square of row) {
                if (square === null) {
                    emptyCount++;
                } else {
                    if (emptyCount > 0) {
                        fenRow += emptyCount;
                        emptyCount = 0;
                    }
                    fenRow += square;
                }
            }

            if (emptyCount > 0) {
                fenRow += emptyCount;
            }

            return fenRow;
        });

        return `${rows.join('/')} ${activeColor} ${castling} ${enPassant} ${halfmove} ${fullmove}`;
    }

    static movePiece(fen, from, to, options = {}) {
        // Parse current FEN
        const { board, gameState } = this.parseFen(fen);
        
        // Convert algebraic notation to indices if needed
        const fromPos = typeof from === 'string' ? 
            this.algebraicToIndices(from) : 
            { row: from.row, col: from.col };
            
        const toPos = typeof to === 'string' ? 
            this.algebraicToIndices(to) : 
            { row: to.row, col: to.col };

        // Get pieces
        const movingPiece = board[fromPos.row][fromPos.col];
        const capturedPiece = board[toPos.row][toPos.col];

        if (!movingPiece) {
            throw new Error('No piece at source position');
        }

        // Make the move
        board[toPos.row][toPos.col] = options.promotion || movingPiece;
        board[fromPos.row][fromPos.col] = null;

        // Handle en passant capture
        if (options.enPassant && gameState.enPassant === this.indicesToAlgebraic(toPos.row, toPos.col)) {
            // Remove the captured pawn - it's on the same rank as the capturing pawn
            const capturedPawnRow = fromPos.row;
            board[capturedPawnRow][toPos.col] = null;
            
            // Add to captured pieces
            const capturedPawnPiece = gameState.activeColor === 'w' ? 'p' : 'P';
            gameState.capturedPieces = gameState.capturedPieces || [];
            gameState.capturedPieces.push(capturedPawnPiece);
        } else if (capturedPiece) {
            // Normal capture handling
            gameState.capturedPieces = gameState.capturedPieces || [];
            gameState.capturedPieces.push(capturedPiece);
        }

        // Handle castling
        if (options.castling) {
            const rookRow = gameState.activeColor === 'w' ? 7 : 0;
            if (options.castling === 'king') {
                board[rookRow][7] = null; // Clear rook's original square
                board[rookRow][5] = gameState.activeColor === 'w' ? 'R' : 'r'; // Place rook
            } else if (options.castling === 'queen') {
                board[rookRow][0] = null; // Clear rook's original square
                board[rookRow][3] = gameState.activeColor === 'w' ? 'R' : 'r'; // Place rook
            }
        }

        // Update game state
        gameState.activeColor = gameState.activeColor === 'w' ? 'b' : 'w';

        // Update castling rights
        if (movingPiece === 'K') {
            gameState.castling = gameState.castling.replace(/[KQ]/g, '');
        } else if (movingPiece === 'k') {
            gameState.castling = gameState.castling.replace(/[kq]/g, '');
        } else if (movingPiece === 'R') {
            if (fromPos.col === 0 && fromPos.row === 7) gameState.castling = gameState.castling.replace('Q', '');
            if (fromPos.col === 7 && fromPos.row === 7) gameState.castling = gameState.castling.replace('K', '');
        } else if (movingPiece === 'r') {
            if (fromPos.col === 0 && fromPos.row === 0) gameState.castling = gameState.castling.replace('q', '');
            if (fromPos.col === 7 && fromPos.row === 0) gameState.castling = gameState.castling.replace('k', '');
        }
        if (gameState.castling === '') gameState.castling = '-';

        // Update en passant target square according to standard
        if (movingPiece.toLowerCase() === 'p' && Math.abs(fromPos.row - toPos.row) === 2) {
            const file = String.fromCharCode('a'.charCodeAt(0) + toPos.col);
            const epRank = gameState.activeColor === 'w' ? '6' : '3';  // Rank based on active color
            
            // Check if the active color has a legal en passant capture
            const canCaptureEnPassant = () => {
                const enemyPawn = gameState.activeColor === 'w' ? 'P' : 'p';
                const attackerRow = toPos.row;  // The pawns need to be on the same rank
                
                // Check adjacent files for enemy pawns that could capture
                return (toPos.col > 0 && board[attackerRow][toPos.col - 1] === enemyPawn) ||
                    (toPos.col < 7 && board[attackerRow][toPos.col + 1] === enemyPawn);
            };

            gameState.enPassant = canCaptureEnPassant() ? file + epRank : '-';
        } else {
            gameState.enPassant = '-';
        }

        // Update move counters
        const isPawnMove = movingPiece.toLowerCase() === 'p';
        if (isPawnMove || capturedPiece || options.enPassant) {
            gameState.halfmove = '0';
        } else {
            gameState.halfmove = (parseInt(gameState.halfmove) + 1).toString();
        }

        if (gameState.activeColor === 'w') {
            gameState.fullmove = (parseInt(gameState.fullmove) + 1).toString();
        }

        // Generate and return new FEN
        return this.generateFen(board, gameState);
    }

    static algebraicToIndices(square) {
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = 8 - parseInt(square.charAt(1));
        return { row: rank, col: file };
    }

    static indicesToAlgebraic(row, col) {
        const file = String.fromCharCode('a'.charCodeAt(0) + col);
        const rank = 8 - row;
        return `${file}${rank}`;
    }
}

class PGNHandler {
    static validatePGN(pgnText) {
        if (!pgnText || typeof pgnText !== 'string') {
            throw new Error('Invalid PGN: Empty or invalid input');
        }

        if (!pgnText.includes('\n\n')) {
            throw new Error('Invalid PGN: Missing moves section');
        }

        const [headerSection, moveSection] = pgnText.split(/\n\n/);

        // Check required tags
        const requiredTags = ['Event', 'Site', 'Date', 'Round', 'White', 'Black', 'Result'];
        for (const tag of requiredTags) {
            if (!headerSection.includes(`[${tag} "`)) {
                throw new Error(`Invalid PGN: Missing required tag [${tag}]`);
            }
        }

        return true;
    }

    static parseMetadata(metadataStr) {
        const metadata = {};
        // Match anything between square brackets that follows the pattern [Key "Value"]
        const tagRegex = /\[(\w+)\s+"([^"]+)"\]/g;
        let match;

        while ((match = tagRegex.exec(metadataStr)) !== null) {
            const [_, key, value] = match;
            metadata[key] = value;
        }

        return metadata;
    }

    static validatePGN(pgnText) {
        if (!pgnText || typeof pgnText !== 'string') {
            throw new Error('Invalid PGN: Empty or invalid input');
        }

        if (!pgnText.includes('\n\n')) {
            throw new Error('Invalid PGN: Missing moves section');
        }

        const [headerSection, moveSection] = pgnText.split(/\n\n/);

        // Check required tags
        const requiredTags = ['Event', 'Site', 'Date', 'Round', 'White', 'Black', 'Result'];
        for (const tag of requiredTags) {
            if (!headerSection.includes(`[${tag} "`)) {
                throw new Error(`Invalid PGN: Missing required tag [${tag}]`);
            }
        }

        return true;
    }

    static parseMetadata(metadataStr) {
        const metadata = {};
        // Match anything between square brackets that follows the pattern [Key "Value"]
        const tagRegex = /\[(\w+)\s+"([^"]+)"\]/g;
        let match;

        while ((match = tagRegex.exec(metadataStr)) !== null) {
            const [_, key, value] = match;
            metadata[key] = value;
        }

        return metadata;
    }

    static getPossibleSourceSquares(analysis, subTurn) {
        const isWhiteTurn = subTurn==0;
        const { pieceType, targetSquare, capture, sourceInfo } = analysis;
        const [file, rank] = [targetSquare.charAt(0), parseInt(targetSquare.charAt(1))];
        const fileIndex = file.charCodeAt(0) - 'a'.charCodeAt(0);

        const isValidSquare = (f, r) => {
            return f >= 'a' && f <= 'h' && r >= 1 && r <= 8;
        };

        const addSquareToDirection = (dx, dy, maxSteps = 7) => {
            const squares = [];
            for (let i = 1; i <= maxSteps; i++) {
                const newFile = String.fromCharCode('a'.charCodeAt(0) + (fileIndex + dx * i));
                const newRank = rank + dy * i;
                if (isValidSquare(newFile, newRank)) {
                    squares.push(newFile + newRank);
                }
            }
            return squares.length > 0 ? [squares] : [];
        };

        let directions = [];
        switch (pieceType.toUpperCase()) {
            case 'P':
                const direction = isWhiteTurn ? -1 : 1;  // Reversed for source squares
                if (capture) {
                    directions.push(...addSquareToDirection(1, direction, 1));
                    directions.push(...addSquareToDirection(-1, direction, 1));
                } else {
                    // Single square back
                    directions.push(...addSquareToDirection(0, direction, 1));
                    
                    // Two squares back only if target is rank 4 (white) or 5 (black)
                    if (rank === (isWhiteTurn ? 4 : 5)) {
                        directions.push(...addSquareToDirection(0, direction * 2, 1));
                    }
                }
                break;
            case 'N':
                [[-2,-1], [-2,1], [2,-1], [2,1], [-1,-2], [-1,2], [1,-2], [1,2]]
                    .forEach(([dx, dy]) => directions.push(...addSquareToDirection(dx, dy, 1)));
                break;

            case 'B':
                [[-1,-1], [1,-1], [-1,1], [1,1]].forEach(([dx, dy]) => 
                    directions.push(...addSquareToDirection(dx, dy)));
                break;

            case 'R':
                [[-1,0], [1,0], [0,-1], [0,1]].forEach(([dx, dy]) => 
                    directions.push(...addSquareToDirection(dx, dy)));
                break;

            case 'Q':
                [[-1,-1], [1,-1], [-1,1], [1,1], [-1,0], [1,0], [0,-1], [0,1]].forEach(([dx, dy]) => 
                    directions.push(...addSquareToDirection(dx, dy)));
                break;

            case 'K':
                [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]]
                    .forEach(([dx, dy]) => directions.push(...addSquareToDirection(dx, dy, 1)));
                break;
        }

        if (sourceInfo) {
            directions = directions.map(direction => {
                let filtered = direction;
                if (sourceInfo.match(/[a-h]/)) {
                    filtered = filtered.filter(square => square.charAt(0) === sourceInfo);
                } else if (sourceInfo.match(/[1-8]/)) {
                    filtered = filtered.filter(square => square.charAt(1) === sourceInfo);
                } else if (sourceInfo.match(/[a-h][1-8]/)) {
                    filtered = filtered.filter(square => square === sourceInfo);
                }
                return filtered;
            }).filter(dir => dir.length > 0);
        }

        return directions;
    }

    static findSourceSquare(pieceType, directions, fen) {
        const validSquares = [];
        const flatDirections = directions.flat().join(', ');

        // Search each direction until blocked
        for (const directionSquares of directions) {
            const piecesInDirection = FenParser.getPiecesAtSquares(directionSquares, fen);
            
            // Check squares in this direction until blocked
            for (let i = 0; i < directionSquares.length; i++) {
                const piece = piecesInDirection[i];
                
                if (piece === pieceType) {
                    validSquares.push(directionSquares[i]);
                    break; // Found piece in this direction
                }
                
                if (piece !== null) {
                    break; // Path is blocked
                }
            }
        }

        if (validSquares.length === 0) {
            throw new Error(`No ${pieceType} found in any direction: ${flatDirections}`);
        }
        if (validSquares.length > 1) {
            throw new Error(`Ambiguous move: ${pieceType} found at multiple squares: ${validSquares.join(', ')}`);
        }

        return validSquares[0];
    }

    static analyzeSingleMove(move, subTurn) {
        const isWhiteTurn = subTurn==0;
        // Handle castling first
        if (move.startsWith('O-O')) {
            const isKingSide = move === 'O-O';
            const possibleMoves = isWhiteTurn ? ['g1', 'c1'] : ['g8', 'c8'];
            return {
                pieceType: isWhiteTurn ? 'K' : 'k',
                targetSquare: isKingSide ? possibleMoves[0] : possibleMoves[1],
                sourceInfo: isWhiteTurn ? 'e1' :'e8',  // Changed from e1/e8 to just the current color's square
                capture: false,
                castling: isKingSide ? 'king' : 'queen',
                check: move.includes('+') || move.includes('#'),
                promotion: null,
                enPassant: false
            };
        }

        // Regular move analysis
        const analysis = {
            pieceType: null,
            targetSquare: null,
            sourceInfo: null,
            capture: move.includes('x'),
            castling: null,
            check: move.includes('+') || move.includes('#'),
            promotion: null,
            enPassant: false
        };

        // Remove check/mate symbols for further processing
        move = move.replace(/[+#]$/, '');

        // Handle promotion
        if (move.includes('=')) {
            analysis.promotion = move.split('=')[1];
            move = move.split('=')[0];
        }

        // Determine piece type
        const pieces = ['K', 'Q', 'R', 'B', 'N'];
        analysis.pieceType = pieces.includes(move[0]) ? move[0] : 'P';
        // Get target square (always the last two characters, except for promotion)
        analysis.targetSquare = move.slice(-2);

        // Get source information (file or rank)
        if (analysis.pieceType !== 'P') {
            const sourceInfo = move.slice(1, -2).replace('x', '');
            if (sourceInfo) {
                analysis.sourceInfo = sourceInfo;
            }
        } else {
            const sourceInfo = move.slice(0, -2).replace('x', '');
            if (sourceInfo) {
                analysis.sourceInfo = sourceInfo;
            }
        }
        if (!isWhiteTurn) {
            analysis.pieceType = analysis.pieceType.toLowerCase();
        }

        // For pawn captures, check if it's potentially an en passant
        if (analysis.pieceType.toLowerCase() === 'p' && analysis.capture) {
            const [file, rank] = [analysis.targetSquare.charAt(0), analysis.targetSquare.charAt(1)];
            const expectedRank = isWhiteTurn ? '6' : '3';
            if (rank === expectedRank) {
                analysis.enPassant = true;
            }
        }

        return analysis;
    }

    static applyMove(fen, sourceSquare, targetSquare, analysis) {
        const options = {
            promotion: analysis.promotion,
            castling: analysis.castling
        };

        return FenParser.movePiece(fen, sourceSquare, targetSquare, options);
    }

    static parseMoveText(moveText) {
        let currentFen = FenParser.getDefaultFen();
        const positions = [currentFen];
        
        // Remove comments and variations
        moveText = moveText.replace(/\{[^}]*\}/g, ''); // Remove comments in curly braces
        moveText = moveText.replace(/\([^)]*\)/g, ''); // Remove variations in parentheses
        
        // Split into move numbers and actual moves
        const moves = moveText.trim().split(/\d+\./).filter(Boolean);
        
        try {
            for (let moveIndex = 0; moveIndex < moves.length; moveIndex++) {
                const move = moves[moveIndex];
                // Split into white and black moves
                const subMoves = move.trim().split(/\s+/).filter(Boolean);
                
                subMoves.forEach((subMove, i) => {
                    try {
                        const analysis = this.analyzeSingleMove(subMove, i);
                        let sourceSquare;
                        if (analysis.castling) {
                            sourceSquare = analysis.sourceInfo;
                        } else {
                            const possibleSourceSquares = this.getPossibleSourceSquares(analysis, i);
                            try {
                                sourceSquare = this.findSourceSquare(analysis.pieceType, possibleSourceSquares, currentFen);
                            } catch (error) {
                                console.error(positions);
                                const errorMessage = [
                                    `Move Number: ${moveIndex + 1}${i === 0 ? '' : '...'}`,
                                    `Move: ${subMove}`,
                                    `Error: ${error.message}`,
                                    `Current Position: ${currentFen}`
                                ].join('\n');
                                throw new Error(errorMessage);
                            }
                        }
                        currentFen = FenParser.movePiece(currentFen, sourceSquare, analysis.targetSquare, analysis);
                        positions.push(currentFen);
                    } catch (error) {
                        // Add move context if not already present
                        if (!error.message.includes('Move Number:')) {
                            const errorMessage = [
                                `Move Number: ${moveIndex + 1}${i === 0 ? '' : '...'}`,
                                `Move: ${subMove}`,
                                `Error: ${error.message}`,
                                `Current Position: ${currentFen}`
                            ].join('\n');
                            throw new Error(errorMessage);
                        }
                        throw error;
                    }
                });
            }
            return positions;
        } catch (error) {
            // Re-throw with preserving the enhanced error message
            throw new Error(error.message);
        }
    }

    static parsePGN(pgnText) {
        this.validatePGN(pgnText);
        
        const [metadataStr, movesStr] = pgnText.split(/\n\n/);
        const metadata = this.parseMetadata(metadataStr);
        
        // Look for end game token
        const endGameTokens = ['1/2-1/2', '1-0', '0-1'];
        metadata.Result = endGameTokens.find(token => movesStr.includes(token)) || null;
        
        // Strip the result token if found
        const cleanMovesStr = metadata.Result ? movesStr.replace(metadata.Result, '').trim() : movesStr;
        
        const positions = this.parseMoveText(cleanMovesStr);
        return { metadata, positions };
    }
}

class Board {
    constructor(element) {
        this.element = element;
        this.currentFen = null;
        this.lastBoard = null;
        this.direction = 'forward';
        this.isUserMove = false;  // New flag for drag and drop moves
        
        this.colors = {
            light: '#f0d9b5',
            dark: '#b58863'
        };
    }

    isValidPosition(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    clearHighlights() {
        this.element.querySelectorAll('.square').forEach(square => {
            const isLight = (parseInt(square.dataset.row) + parseInt(square.dataset.col)) % 2 === 0;
            square.style.backgroundColor = isLight ? this.colors.light : this.colors.dark;
            square.classList.remove('ring-4', 'ring-inset', 'ring-black/20');
        });
    }

    highlightSquare(row, col) {
        const square = this.element.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (square) {
            square.classList.add('ring-4', 'ring-inset', 'ring-black/20');
        }
    }

    createSquareElement(row, col) {
        const square = document.createElement('div');
        const isLight = (row + col) % 2 === 0;
        
        square.className = `
            square
            aspect-square 
            flex 
            items-center 
            justify-center
            relative
        `;
        
        square.style.backgroundColor = isLight ? this.colors.light : this.colors.dark;
        square.dataset.row = row;
        square.dataset.col = col;

        // Add rank and file labels
        if (col === 0) {
            const rankLabel = document.createElement('div');
            rankLabel.className = `
                absolute 
                left-1 
                top-1 
                text-xs 
                font-semibold
                ${isLight ? 'text-[#b58863]' : 'text-[#f0d9b5]'}
            `;
            rankLabel.textContent = 8 - row;
            square.appendChild(rankLabel);
        }

        if (row === 7) {
            const fileLabel = document.createElement('div');
            fileLabel.className = `
                absolute 
                right-1 
                bottom-1 
                text-xs 
                font-semibold
                ${isLight ? 'text-[#b58863]' : 'text-[#f0d9b5]'}
            `;
            fileLabel.textContent = String.fromCharCode(97 + col);
            square.appendChild(fileLabel);
        }

        return square;
    }

    createPieceElement(fen) {
        const pieceElement = document.createElement('div');
        pieceElement.className = `
            piece
            w-full h-full
            flex items-center justify-center
            text-[calc(min(80vw,80vh)/9)]
            hover:scale-110 
            transition-transform duration-200
            select-none
            cursor-grab
            active:cursor-grabbing
            outline-0
        `;
        // Add the explicit style for focus state
        pieceElement.style.outline = 'none';
        
        pieceElement.draggable = true;
        pieceElement.dataset.color = Piece.getColor(fen);
        pieceElement.dataset.type = fen;
        pieceElement.textContent = Piece.getSymbol(fen);

        return pieceElement;
    }

    findMovedPiece(oldBoard, newBoard) {
        // Get piece maps for each position
        const getPieceMap = (board) => {
            const map = new Map();
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const positions = map.get(piece) || [];
                        positions.push({ row, col });
                        map.set(piece, positions);
                    }
                }
            }
            return map;
        };

        const oldPieces = getPieceMap(oldBoard);
        const newPieces = getPieceMap(newBoard);

        // Find the piece that moved by comparing positions
        for (const [piece, oldPositions] of oldPieces) {
            const newPositions = newPieces.get(piece) || [];
            
            if (JSON.stringify(oldPositions.sort()) !== JSON.stringify(newPositions.sort())) {
                if (this.direction === 'forward') {
                    const from = oldPositions.find(oldPos => 
                        !newPositions.some(newPos => 
                            newPos.row === oldPos.row && newPos.col === oldPos.col
                        )
                    );
                    const to = newPositions.find(newPos => 
                        !oldPositions.some(oldPos => 
                            oldPos.row === newPos.row && oldPos.col === newPos.col
                        )
                    );
                    
                    // Only return if we found both positions
                    if (from && to) {
                        return {
                            from: { ...from, piece },
                            to: { ...to, piece },
                            captured: oldBoard[to.row][to.col]
                        };
                    }
                } else {
                    const to = oldPositions.find(oldPos => 
                        !newPositions.some(newPos => 
                            newPos.row === oldPos.row && newPos.col === oldPos.col
                        )
                    );
                    const from = newPositions.find(newPos => 
                        !oldPositions.some(oldPos => 
                            oldPos.row === newPos.row && oldPos.col === newPos.col
                        )
                    );
                    
                    // Only return if we found both positions
                    if (from && to) {
                        return {
                            from: { ...from, piece },
                            to: { ...to, piece },
                            captured: newBoard[from.row][from.col]
                        };
                    }
                }
            }
        }

        return { from: null, to: null, captured: null };
    }

    render(fen) {
        // Store current FEN and parse boards
        const oldBoard = this.lastBoard;
        const { board: newBoard } = FenParser.parseFen(fen);
        // Only find moved piece if it's not a user drag-drop move
        const move = oldBoard && !this.isUserMove ? this.findMovedPiece(oldBoard, newBoard) : null;
        
        // Reset the flag after use
        this.isUserMove = false;
        
        // Update stored board state
        this.currentFen = fen;
        this.lastBoard = newBoard;

        this.element.innerHTML = '';
        this.element.className = 'grid grid-cols-8 w-full h-full border-2 border-gray-800 bg-white shadow-xl rounded-sm overflow-hidden relative';

        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = this.createSquareElement(row, col);
                const piece = newBoard[row][col];

                if (piece) {
                    const pieceElement = this.createPieceElement(piece);
                    
                    // Determine if this piece should be animated
                    let shouldAnimate = false;
                    let startPos = null;

                    if (move && move.from && move.to) {  // Check that move has valid positions
                        // In forward direction, animate piece to its new position
                        if (this.direction === 'forward' && 
                            row === move.to.row && 
                            col === move.to.col &&
                            piece === move.to.piece) {
                            shouldAnimate = true;
                            startPos = move.from;
                        }
                        // In backward direction, animate piece from its current position
                        else if (this.direction === 'backward' && 
                                row === move.from.row && 
                                col === move.from.col &&
                                piece === move.from.piece) {
                            shouldAnimate = true;
                            startPos = move.to;
                        }
                    }

                    if (shouldAnimate && startPos) {
                        pieceElement.style.zIndex = '20';
                        
                        const deltaRow = startPos.row - row;
                        const deltaCol = startPos.col - col;
                        
                        pieceElement.style.transform = `translate(${deltaCol * 100}%, ${deltaRow * 100}%)`;
                        pieceElement.offsetHeight; // Force reflow
                        
                        pieceElement.style.transition = 'transform 0.3s ease-in-out';
                        
                        requestAnimationFrame(() => {
                            pieceElement.style.transform = 'translate(0, 0)';
                        });
                        
                        pieceElement.addEventListener('transitionend', () => {
                            pieceElement.style.transition = '';
                            pieceElement.style.transform = '';
                            pieceElement.style.zIndex = '';
                        }, { once: true });
                    }

                    square.appendChild(pieceElement);
                }

                this.element.appendChild(square);
            }
        }
    }

    // Get current state methods
    getCurrentFen() {
        return this.currentFen;
    }

    getPieceAt(row, col) {
        if (!this.isValidPosition(row, col)) return null;
        
        const { board } = FenParser.parseFen(this.currentFen);
        return board[row][col];
    }

    // Notation conversion utilities
    getSquareNotation(row, col) {
        const file = String.fromCharCode(97 + col); // 'a' through 'h'
        const rank = 8 - row; // 1 through 8
        return `${file}${rank}`;
    }

    getSquareFromNotation(notation) {
        const file = notation.charAt(0).toLowerCase();
        const rank = notation.charAt(1);
        
        const col = file.charCodeAt(0) - 97; // 'a' is 97 in ASCII
        const row = 8 - parseInt(rank);

        return { row, col };
    }
}

class SideBoard {
    constructor(color, containerId, pieceValues = {
        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,
        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1
    }) {
        this.color = color;
        this.container = document.getElementById(containerId);
        this.pieceValues = pieceValues;
        this.GRID_COLS = 2;
        this.GRID_ROWS = 8;
        
        if (!this.container) {
            throw new Error(`Container with id '${containerId}' not found`);
        }
        
        this.piecesContainer = this.container.querySelector('.pieces-container');
        this.setupGrid();
    }

    setupGrid() {
        // Clear existing content
        this.piecesContainer.innerHTML = '';
        
        // Set up CSS Grid with template areas
        this.piecesContainer.style.gridTemplateAreas = this.generateGridAreas();
    }
    generateGridAreas() {
        // Generate grid areas for 2x8 grid, column-first naming
        const areas = [];
        for (let row = 0; row < this.GRID_ROWS; row++) {
            const rowAreas = [];
            for (let col = 0; col < this.GRID_COLS; col++) {
                rowAreas.push(`pos${col}_${row}`);
            }
            areas.push(`"${rowAreas.join(' ')}"`);
        }
        return areas.join(' ');
    }

    createPieceElement(fenPiece) {
        const cell = document.createElement('div');
        cell.className = `
            piece
            w-full h-full
            flex items-center justify-center
            text-[length:clamp(1rem,min(3.5vw,3.5vh),2.2rem)]
            opacity-80
            hover:opacity-100
            transition-opacity
            cursor-default
        `;
        
        cell.dataset.color = Piece.getColor(fenPiece);
        cell.textContent = Piece.getSymbol(fenPiece);
        
        return cell;
    }

    getGridPosition(index) {
        let col, row;
        
        if (this.color === 'black') {
            // Black captures: Start from right column (col 1)
            col = 1 - Math.floor(index / this.GRID_ROWS); // Start with 1, then 0
            row = index % this.GRID_ROWS; // Fill top to bottom
        } else {
            // White captures: Start from left column (col 0)
            col = Math.floor(index / this.GRID_ROWS);
            row = this.GRID_ROWS - 1 - (index % this.GRID_ROWS); // Fill bottom to top
        }
        
        return { col, row };
    }

    render(capturedPieces) {
        // Clear existing pieces
        this.piecesContainer.innerHTML = '';
        
        // Sort pieces by value (optional)
        const sortedPieces = [...capturedPieces].sort((a, b) => 
            this.pieceValues[b] - this.pieceValues[a]
        );

        // Add pieces to grid
        sortedPieces.forEach((fenPiece, index) => {
            if (index >= this.GRID_COLS * this.GRID_ROWS) return; // Skip if grid is full
            
            const pieceElement = this.createPieceElement(fenPiece);
            const { col, row } = this.getGridPosition(index);
            
            // Position the piece using grid-area
            pieceElement.style.gridArea = `pos${col}_${row}`;
            this.piecesContainer.appendChild(pieceElement);
        });
    }
}

class Moves {
    static isInBounds(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    static getPieceMoves(fen, fromRow, fromCol) {
        const { board, gameState } = FenParser.parseFen(fen);
        const moves = [];

        // Check if any valid moves put opponent in check
        const isInCheck = this.isKingInCheck(board, gameState.activeColor === 'w');
        
        // For finding check, we don't need actual source position
        if (fromRow === 0 && fromCol === 0 && isInCheck) {
            return [{ check: true }];
        }
        
        const piece = board[fromRow][fromCol];
        if (!piece) return moves;
        
        // Verify piece color matches current turn
        const pieceColor = Piece.isWhite(piece) ? 'w' : 'b';
        if (pieceColor !== gameState.activeColor) return moves;

        const pieceType = piece.toLowerCase();

        switch (pieceType) {
            case 'p':
                moves.push(...this.getPawnMoves(board, fromRow, fromCol, piece, gameState.enPassant));
                break;
            case 'n':
                moves.push(...this.getKnightMoves(board, fromRow, fromCol, piece));
                break;
            case 'b':
                moves.push(...this.getBishopMoves(board, fromRow, fromCol, piece));
                break;
            case 'r':
                moves.push(...this.getRookMoves(board, fromRow, fromCol, piece));
                break;
            case 'q':
                moves.push(...this.getQueenMoves(board, fromRow, fromCol, piece));
                break;
            case 'k':
                moves.push(...this.getKingMoves(board, fromRow, fromCol, piece, gameState.castling));
                break;
        }

        // Filter moves that would put/leave king in check
        return moves.filter(move => !this.movePutsKingInCheck(board, fromRow, fromCol, move.row, move.col, piece));
    }

    static getPawnMoves(board, row, col, piece, enPassantSquare) {
        const moves = [];
        const direction = Piece.isWhite(piece) ? -1 : 1;
        const startRank = Piece.isWhite(piece) ? 6 : 1;
        
        // Forward move
        if (this.isInBounds(row + direction, col) && !board[row + direction][col]) {
            moves.push({ row: row + direction, col: col });
            
            // Double move from start
            if (row === startRank && !board[row + 2 * direction][col]) {
                moves.push({ row: row + 2 * direction, col: col });
            }
        }
        
        // Captures
        for (const captureCol of [col - 1, col + 1]) {
            if (this.isInBounds(row + direction, captureCol)) {
                const target = board[row + direction][captureCol];
                if (target && Piece.isWhite(target) !== Piece.isWhite(piece)) {
                    moves.push({ row: row + direction, col: captureCol });
                }
            }
        }
        
        // En passant
        if (enPassantSquare !== '-') {
            const epSquare = FenParser.algebraicToIndices(enPassantSquare);
            if (Math.abs(col - epSquare.col) === 1 && row + direction === epSquare.row) {
                moves.push({ row: epSquare.row, col: epSquare.col, enPassant: true });
            }
        }

        return moves;
    }

    static getKnightMoves(board, row, col, piece) {
        const moves = [];
        const offsets = [[-2,-1], [-2,1], [2,-1], [2,1], [-1,-2], [-1,2], [1,-2], [1,2]];
        
        for (const [dRow, dCol] of offsets) {
            const newRow = row + dRow;
            const newCol = col + dCol;
            
            if (this.isInBounds(newRow, newCol)) {
                const target = board[newRow][newCol];
                if (!target || Piece.isWhite(target) !== Piece.isWhite(piece)) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        }
        
        return moves;
    }

    static getBishopMoves(board, row, col, piece) {
        return this.getSlidingMoves(board, row, col, piece, [[-1,-1], [-1,1], [1,-1], [1,1]]);
    }

    static getRookMoves(board, row, col, piece) {
        return this.getSlidingMoves(board, row, col, piece, [[-1,0], [1,0], [0,-1], [0,1]]);
    }

    static getQueenMoves(board, row, col, piece) {
        return this.getSlidingMoves(board, row, col, piece, 
            [[-1,-1], [-1,1], [1,-1], [1,1], [-1,0], [1,0], [0,-1], [0,1]]);
    }

    static getSlidingMoves(board, row, col, piece, directions) {
        const moves = [];
        
        for (const [dRow, dCol] of directions) {
            let newRow = row + dRow;
            let newCol = col + dCol;
            
            while (this.isInBounds(newRow, newCol)) {
                const target = board[newRow][newCol];
                if (!target) {
                    moves.push({ row: newRow, col: newCol });
                } else {
                    if (Piece.isWhite(target) !== Piece.isWhite(piece)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                    break;
                }
                newRow += dRow;
                newCol += dCol;
            }
        }
        
        return moves;
    }

    static getKingMoves(board, row, col, piece, castling) {
        const moves = [];
        const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
        
        // Normal moves
        for (const [dRow, dCol] of directions) {
            const newRow = row + dRow;
            const newCol = col + dCol;
            
            if (this.isInBounds(newRow, newCol)) {
                const target = board[newRow][newCol];
                if (!target || Piece.isWhite(target) !== Piece.isWhite(piece)) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        }
        
        // Castling
        const isWhite = Piece.isWhite(piece);
        const baseRank = isWhite ? 7 : 0;
        
        if (row === baseRank && col === 4) {
            // Kingside castling
            if (castling.includes(isWhite ? 'K' : 'k') &&
                !board[baseRank][5] && !board[baseRank][6] &&
                !this.isSquareAttacked(board, baseRank, 4, !isWhite) &&
                !this.isSquareAttacked(board, baseRank, 5, !isWhite)) {
                moves.push({ row: baseRank, col: 6, castling: 'king' });
            }
            
            // Queenside castling
            if (castling.includes(isWhite ? 'Q' : 'q') &&
                !board[baseRank][3] && !board[baseRank][2] && !board[baseRank][1] &&
                !this.isSquareAttacked(board, baseRank, 4, !isWhite) &&
                !this.isSquareAttacked(board, baseRank, 3, !isWhite)) {
                moves.push({ row: baseRank, col: 2, castling: 'queen' });
            }
        }
        
        return moves;
    }

    static isSquareAttacked(board, row, col, byWhite) {
        // Check pawn attacks
        const pawnDir = byWhite ? 1 : -1;
        for (const dCol of [-1, 1]) {
            const attackRow = row + pawnDir;
            const attackCol = col + dCol;
            if (this.isInBounds(attackRow, attackCol)) {
                const piece = board[attackRow][attackCol];
                if (piece && piece.toLowerCase() === 'p' && Piece.isWhite(piece) === byWhite) {
                    return true;
                }
            }
        }

        // Check knight attacks
        const knightOffsets = [[-2,-1], [-2,1], [2,-1], [2,1], [-1,-2], [-1,2], [1,-2], [1,2]];
        for (const [dRow, dCol] of knightOffsets) {
            const attackRow = row + dRow;
            const attackCol = col + dCol;
            if (this.isInBounds(attackRow, attackCol)) {
                const piece = board[attackRow][attackCol];
                if (piece && piece.toLowerCase() === 'n' && Piece.isWhite(piece) === byWhite) {
                    return true;
                }
            }
        }

        // Check sliding pieces (bishop, rook, queen)
        const directions = [
            [-1,-1], [-1,1], [1,-1], [1,1], // Bishop/Queen
            [-1,0], [1,0], [0,-1], [0,1]    // Rook/Queen
        ];

        for (const [dRow, dCol] of directions) {
            let attackRow = row + dRow;
            let attackCol = col + dCol;
            
            while (this.isInBounds(attackRow, attackCol)) {
                const piece = board[attackRow][attackCol];
                if (piece) {
                    if (Piece.isWhite(piece) === byWhite) {
                        const pieceType = piece.toLowerCase();
                        const isDiagonal = Math.abs(dRow) === Math.abs(dCol);
                        const isOrthogonal = dRow === 0 || dCol === 0;
                        
                        if ((isDiagonal && (pieceType === 'b' || pieceType === 'q')) ||
                            (isOrthogonal && (pieceType === 'r' || pieceType === 'q'))) {
                            return true;
                        }
                    }
                    break;
                }
                attackRow += dRow;
                attackCol += dCol;
            }
        }

        // Check king attacks
        const kingOffsets = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
        for (const [dRow, dCol] of kingOffsets) {
            const attackRow = row + dRow;
            const attackCol = col + dCol;
            if (this.isInBounds(attackRow, attackCol)) {
                const piece = board[attackRow][attackCol];
                if (piece && piece.toLowerCase() === 'k' && Piece.isWhite(piece) === byWhite) {
                    return true;
                }
            }
        }

        return false;
    }

    static isKingInCheck(board, isWhiteKing) {
        // Find the king's position
        let kingRow, kingCol;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const p = board[r][c];
                if (p && p.toLowerCase() === 'k' && Piece.isWhite(p) === isWhiteKing) {
                    kingRow = r;
                    kingCol = c;
                    break;
                }
            }
            if (kingRow !== undefined) break;
        }
        
        return this.isSquareAttacked(board, kingRow, kingCol, !isWhiteKing);
    }

    static isCheckmate(board, isWhiteKing) {
        // First check if king is in check
        if (!this.isKingInCheck(board, isWhiteKing)) {
            return false;
        }

        // Generate all possible moves for the checked side
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = board[row][col];
                if (!piece || Piece.isWhite(piece) !== isWhiteKing) continue;

                switch (piece.toLowerCase()) {
                    case 'p':
                        if (this.getPawnMoves(board, row, col, piece, '-').some(
                            move => !this.movePutsKingInCheck(board, row, col, move.row, move.col, piece)
                        )) return false;
                        break;
                    case 'n':
                        if (this.getKnightMoves(board, row, col, piece).some(
                            move => !this.movePutsKingInCheck(board, row, col, move.row, move.col, piece)
                        )) return false;
                        break;
                    case 'b':
                        if (this.getBishopMoves(board, row, col, piece).some(
                            move => !this.movePutsKingInCheck(board, row, col, move.row, move.col, piece)
                        )) return false;
                        break;
                    case 'r':
                        if (this.getRookMoves(board, row, col, piece).some(
                            move => !this.movePutsKingInCheck(board, row, col, move.row, move.col, piece)
                        )) return false;
                        break;
                    case 'q':
                        if (this.getQueenMoves(board, row, col, piece).some(
                            move => !this.movePutsKingInCheck(board, row, col, move.row, move.col, piece)
                        )) return false;
                        break;
                    case 'k':
                        if (this.getKingMoves(board, row, col, piece, '-').some(
                            move => !this.movePutsKingInCheck(board, row, col, move.row, move.col, piece)
                        )) return false;
                        break;
                }
            }
        }

        return true;
    }

    static movePutsKingInCheck(board, fromRow, fromCol, toRow, toCol, piece) {
        // Create a copy of the board
        const tempBoard = board.map(row => [...row]);
        
        // Make the move on the temporary board
        tempBoard[toRow][toCol] = piece;
        tempBoard[fromRow][fromCol] = null;
        
        // Find the king's position
        const isWhite = Piece.isWhite(piece);
        let kingRow, kingCol;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const p = tempBoard[r][c];
                if (p && p.toLowerCase() === 'k' && Piece.isWhite(p) === isWhite) {
                    kingRow = r;
                    kingCol = c;
                    break;
                }
            }
        }
        
        // Check if the king is under attack
        return this.isSquareAttacked(tempBoard, kingRow, kingCol, !isWhite);
    }

    static isValidMove(fen, fromRow, fromCol, toRow, toCol) {
        const validMoves = this.getPieceMoves(fen, fromRow, fromCol);
        return validMoves.some(move => 
            move.row === toRow && 
            move.col === toCol
        );
    }
}

class Game {
    constructor(fen = null) {
        this.positions = [];
        this.currentIndex = -1;
        this.metadata = {
            Event: "?",
            Site: "?",
            Date: new Date().toISOString().split('T')[0].replace(/-/g, '.'),
            White: "Player White",
            Black: "Player Black",
            Result: "*"
        };
        this.initializeComponents();
        this.board = new Board(this.boardElement);
        
        const initialFen = fen || FenParser.getDefaultFen();
        this.positions = [initialFen];
        this.currentIndex = 0;
        this.updateDisplays();
        
        this.setupEventListeners();
    }

    initializeComponents() {
        this.boardElement = document.getElementById('board');
        if (!this.boardElement) {
            throw new Error('Board element not found');
        }

        this.whiteSideBoard = new SideBoard('white', 'white-captures');
        this.blackSideBoard = new SideBoard('black', 'black-captures');
        
        this.navigationElement = document.getElementById('navigation');
        this.whiteMoveIndicator = document.getElementById('white-indicator');
        this.blackMoveIndicator = document.getElementById('black-indicator');

        this.navigationElement.querySelector('.nav-back').addEventListener('click', () => this.goBack());
        this.navigationElement.querySelector('.nav-forward').addEventListener('click', () => this.goForward());
    }

    setupEventListeners() {
        // Keep existing events
        this.boardElement.addEventListener('dragstart', (e) => this.handleDragStart(e));
        this.boardElement.addEventListener('dragover', (e) => this.handleDragOver(e));
        this.boardElement.addEventListener('drop', (e) => this.handleDrop(e));
        this.boardElement.addEventListener('dragend', (e) => {
            const piece = e.target.closest('.piece');
            if (piece) {
                piece.classList.remove('opacity-50');
            }
        });

        // Add touch events
        this.boardElement.addEventListener('touchstart', (e) => {
            const piece = e.target.closest('.piece');
            if (!piece) return;
            
            const square = piece.parentElement;
            const touch = e.touches[0];
            
            // Store initial touch position
            piece.dataset.touchStartX = touch.clientX;
            piece.dataset.touchStartY = touch.clientY;
            
            // Trigger dragstart equivalent
            const event = new Event('dragstart');
            piece.dispatchEvent(event);
        });

        this.boardElement.addEventListener('touchmove', (e) => {
            const piece = e.target.closest('.piece');
            if (!piece) return;
            
            e.preventDefault();
            
            // Trigger dragover equivalent
            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target) {
                const event = new Event('dragover');
                target.dispatchEvent(event);
            }
        });

        this.boardElement.addEventListener('touchend', (e) => {
            const piece = e.target.closest('.piece');
            if (!piece) return;
            
            const touch = e.changedTouches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (target) {
                // Trigger drop equivalent
                const dropEvent = new Event('drop');
                target.dispatchEvent(dropEvent);
            }
            
            // Cleanup
            delete piece.dataset.touchStartX;
            delete piece.dataset.touchStartY;
        });
    }

    handleDragStart(e) {
        const pieceElement = e.target.closest('.piece');
        if (!pieceElement) return;

        const square = pieceElement.parentElement;
        const { row, col } = square.dataset;

        const { gameState } = FenParser.parseFen(this.getCurrentFen());
        const piece = this.board.getPieceAt(parseInt(row), parseInt(col));
        const pieceColor = Piece.isWhite(piece) ? 'w' : 'b';
        
        if (pieceColor !== gameState.activeColor) {
            e.preventDefault();
            return;
        }

        e.dataTransfer.setData('text/plain', JSON.stringify({
            row: parseInt(row),
            col: parseInt(col)
        }));

        pieceElement.classList.add('opacity-50');
    }

    handleDragOver(e) {
        e.preventDefault();
        
        this.board.clearHighlights();
        
        const draggedPiece = document.querySelector('.piece.opacity-50');
        if (!draggedPiece) return;
        
        const originSquare = draggedPiece.closest('[data-row]');
        if (!originSquare) return;
        
        const fromRow = parseInt(originSquare.dataset.row);
        const fromCol = parseInt(originSquare.dataset.col);
        
        const targetSquare = e.target.closest('[data-row]');
        if (!targetSquare) return;
        
        const toRow = parseInt(targetSquare.dataset.row);
        const toCol = parseInt(targetSquare.dataset.col);
        
        if (Moves.isValidMove(this.getCurrentFen(), fromRow, fromCol, toRow, toCol)) {
            this.board.highlightSquare(toRow, toCol);
        }
    }

    handleDrop(e) {
        e.preventDefault();
        
        this.board.clearHighlights();
        const draggedPiece = document.querySelector('.piece.opacity-50');
        if (draggedPiece) {
            draggedPiece.classList.remove('opacity-50');
        }

        const targetSquare = e.target.closest('[data-row]');
        if (!targetSquare) return;

        const originPos = JSON.parse(e.dataTransfer.getData('text/plain'));
        const targetPos = {
            row: parseInt(targetSquare.dataset.row),
            col: parseInt(targetSquare.dataset.col)
        };

        if (!this.board.isValidPosition(originPos.row, originPos.col) ||
            !this.board.isValidPosition(targetPos.row, targetPos.col)) {
            return;
        }

        this.movePiece(originPos, targetPos);
    }

    movePiece(from, to) {
        if (!this.board.isValidPosition(from.row, from.col) ||
            !this.board.isValidPosition(to.row, to.col) ||
            !Moves.isValidMove(this.getCurrentFen(), from.row, from.col, to.row, to.col)) {
            return false;
        }

        try {
            const validMoves = Moves.getPieceMoves(this.getCurrentFen(), from.row, from.col);
            const targetMove = validMoves.find(move => move.row === to.row && move.col === to.col);
            
            const options = {
                castling: targetMove?.castling || null,
                enPassant: targetMove?.enPassant || null
            };
            
            if (this.isPawnPromotion(to.row, this.board.getPieceAt(from.row, from.col))) {
                const isWhite = Piece.isWhite(this.board.getPieceAt(from.row, from.col));
                options.promotion = isWhite ? 'Q' : 'q';
            }

            this.board.isUserMove = true;

            const newFen = FenParser.movePiece(this.getCurrentFen(), from, to, options);
            
            this.addPosition(newFen);
            return true;
        } catch (error) {
            console.error('Move failed:', error.message);
            return false;
        }
    }

    isPawnPromotion(row, piece) {
        const isPawn = piece.toLowerCase() === 'p';
        const isWhitePawn = piece === 'P';
        return isPawn && ((isWhitePawn && row === 0) || (!isWhitePawn && row === 7));
    }

    // History navigation methods
    getCurrentFen() {
        if (this.currentIndex < 0 || this.currentIndex >= this.positions.length) {
            console.error('Invalid position index:', this.currentIndex);
            return null;
        }
        return this.positions[this.currentIndex];
    }

    canGoForward() {
        return this.currentIndex < this.positions.length - 1;
    }

    canGoBack() {
        return this.currentIndex > 0;
    }

    goForward() {
        if (this.canGoForward()) {
            this.currentIndex++;
            const fen = this.getCurrentFen();
            if (fen) {
                this.updateDisplays();
                return true;
            }
        }
        return false;
    }

    goBack() {
        if (this.canGoBack()) {
            this.currentIndex--;
            const fen = this.getCurrentFen();
            if (fen) {
                this.updateDisplays();
                return true;
            }
        }
        return false;
    }

    goToStart() {
        if (this.positions.length > 0) {
            this.currentIndex = 0;
            this.updateDisplays();
            return true;
        }
        return false;
    }

    goToEnd() {
        if (this.positions.length > 0) {
            this.currentIndex = this.positions.length - 1;
            this.updateDisplays();
            return true;
        }
        return false;
    }

    addPosition(fen) {
        if (this.currentIndex < this.positions.length - 1) {
            // We're creating a new timeline, reset relevant metadata
            this.positions = this.positions.slice(0, this.currentIndex + 1);
            this.metadata.Result = '*';  // Reset game result
        }
        
        this.positions.push(fen);
        this.currentIndex++;
        
        this.updateDisplays();
    }

    updateDisplays() {
        const currentFen = this.getCurrentFen();
        if (!currentFen) {
            console.error('No FEN available for display update');
            return;
        }

        if (this.board) {
            this.board.render(currentFen);
        }
        
        if (this.whiteSideBoard && this.blackSideBoard) {
            try {
                const parsedState = FenParser.parseFen(currentFen);
                if (!parsedState || !parsedState.gameState) {
                    console.error('Invalid game state from FEN:', currentFen);
                    return;
                }
                
                const capturedPieces = parsedState.gameState.capturedPieces || [];
                
                this.whiteSideBoard.render(capturedPieces.filter(p => !Piece.isWhite(p)));
                this.blackSideBoard.render(capturedPieces.filter(p => Piece.isWhite(p)));
            } catch (error) {
                console.error('Error updating captured pieces:', error);
            }
        }

        if (this.navigationElement) {
            const { gameState } = FenParser.parseFen(currentFen);
            const backBtn = this.navigationElement.querySelector('.nav-back');
            const forwardBtn = this.navigationElement.querySelector('.nav-forward');
            const moveNumber = this.navigationElement.querySelector('.move-number');

            backBtn.disabled = !this.canGoBack();
            forwardBtn.disabled = !this.canGoForward();
            moveNumber.textContent = `Move ${gameState.fullmove}`;
        }

        const { gameState } = FenParser.parseFen(currentFen);
        const isWhiteActive = gameState.activeColor === 'w';
        const metadata = this.getMetadata();
        
        const isLastMove = this.currentIndex === this.positions.length - 1;
        let whiteText = metadata.White || "Player White";
        let blackText = metadata.Black || "Player Black";
        let whiteWins = false;
        let blackWins = false;
        
        const { board } = FenParser.parseFen(currentFen);
        if (isLastMove) {
            if (Moves.isKingInCheck(board, isWhiteActive)) {
                if (Moves.isCheckmate(board, isWhiteActive)) {
                    if (isWhiteActive) {
                        whiteText += ' (checkmate)';
                        blackText = metadata.Black + ' wins!';
                        blackWins = true;
                        this.metadata.Result = '0-1';
                    } else {
                        blackText += ' (checkmate)';
                        whiteText = metadata.White + ' wins!';
                        whiteWins = true;
                        this.metadata.Result = '1-0';
                    }
                } else {
                    if (isWhiteActive) {
                        whiteText += ' (check)';
                    } else {
                        blackText += ' (check)';
                    }
                }
            }
            
            if (!whiteWins && !blackWins && metadata.Result && metadata.Result !== '*') {
                if (metadata.Result === '1-0') {
                    whiteText += ' wins!';
                    whiteWins = true;
                } else if (metadata.Result === '0-1') {
                    blackText += ' wins!';
                    blackWins = true;
                } else if (metadata.Result === '1/2-1/2') {
                    whiteText += ' (Draw)';
                    blackText += ' (Draw)';
                }
            }
        }
        
        this.whiteMoveIndicator.className = `
            px-6 py-2
            rounded-xl text-sm font-bold
            transition-all duration-200
            ${whiteWins ? 'bg-amber-400 text-black shadow-[0_0_15px_rgba(251,191,36,0.7)]' :
            isWhiteActive ? 'bg-white text-gray-800 ring-2 ring-gray-400 shadow-xl scale-105' : 
            'text-gray-400'}
        `;
        this.whiteMoveIndicator.textContent = whiteText;
        
        this.blackMoveIndicator.className = `
            px-6 py-2
            rounded-xl text-sm font-bold
            transition-all duration-200
            ${blackWins ? 'bg-amber-400 text-black shadow-[0_0_15px_rgba(251,191,36,0.7)]' :
            !isWhiteActive ? 'bg-gray-800 text-white ring-2 ring-gray-600 shadow-xl scale-105' : 
            'text-gray-400'}
        `;
        this.blackMoveIndicator.textContent = blackText;
    }

    getMetadata() {
        return { ...this.metadata };
    }

    setMetadata(metadata) {
        this.metadata = { ...this.metadata, ...metadata };
    }
}

// Initialize with default board

let chessGame;  // Define game variable in global scope

function initializeGame(fen=null) {
    chessGame = new Game(fen);

}

function initializeMenuHandlers() {
    // Menu Toggle
    document.getElementById('menu-button').addEventListener('click', (e) => {
        e.stopPropagation();
        const dropdown = document.getElementById('menu-dropdown');
        dropdown.classList.toggle('hidden');
    });

    // Close menu when clicking outside
    document.addEventListener('click', () => {
        document.getElementById('menu-dropdown').classList.add('hidden');
    });

    // Import button click
    document.getElementById('import-button').addEventListener('click', () => {
        document.getElementById('pgn-modal').classList.remove('hidden');
    });

    // Cancel import
    document.getElementById('cancel-import').addEventListener('click', () => {
        document.getElementById('pgn-modal').classList.add('hidden');
        document.getElementById('pgn-input').value = '';
    });

    // Confirm import
    document.getElementById('confirm-import').addEventListener('click', () => {
        const pgnText = document.getElementById('pgn-input').value;
        try {
            PGNHandler.validatePGN(pgnText);
            const { metadata, positions } = PGNHandler.parsePGN(pgnText);
            
            // Clean up existing game
            if (chessGame) {
                // Remove only game-specific event listeners
                chessGame.boardElement.replaceWith(chessGame.boardElement.cloneNode(true));
                chessGame.navigationElement.replaceWith(chessGame.navigationElement.cloneNode(true));
                chessGame = null;
            }
            
            // Create fresh game with first position
            initializeGame(positions[0]);
            
            // Add remaining positions
            positions.slice(1).forEach(fen => {
                chessGame.addPosition(fen);
            });
            
            chessGame.setMetadata(metadata);
            chessGame.goToStart();
            
            document.getElementById('pgn-modal').classList.add('hidden');
            document.getElementById('pgn-input').value = '';
            
            Notification.show('PGN imported successfully', 'success');
        } catch (error) {
            Notification.show(error, 'error');
        }
    });

    // FEN import button click
    document.getElementById('import-fen-button').addEventListener('click', () => {
        document.getElementById('fen-modal').classList.remove('hidden');
    });

    // Cancel FEN import
    document.getElementById('cancel-fen-import').addEventListener('click', () => {
        document.getElementById('fen-modal').classList.add('hidden');
        document.getElementById('fen-input').value = '';
    });

    // Confirm FEN import
    document.getElementById('confirm-fen-import').addEventListener('click', () => {
        const fenText = document.getElementById('fen-input').value;
        try {
            // Use existing FenParser validation
            FenParser.validatePosition(fenText);
            
            // Clean up existing game
            if (chessGame) {
                chessGame.boardElement.replaceWith(chessGame.boardElement.cloneNode(true));
                chessGame.navigationElement.replaceWith(chessGame.navigationElement.cloneNode(true));
                chessGame = null;
            }
            
            // Initialize new game with FEN
            initializeGame(fenText);
            
            document.getElementById('fen-modal').classList.add('hidden');
            document.getElementById('fen-input').value = '';
            
            Notification.show('FEN imported successfully', 'success');
        } catch (error) {
            Notification.show(error, 'error');
        }
    });

    document.getElementById('new-game-button').addEventListener('click', () => {
        // Clean up existing game
        if (chessGame) {
            chessGame.boardElement.replaceWith(chessGame.boardElement.cloneNode(true));
            chessGame.navigationElement.replaceWith(chessGame.navigationElement.cloneNode(true));
            chessGame = null;
        }
        
        // Initialize new game
        initializeGame();
        Notification.show('New game started', 'success');
    });
}
// Add this function before the DOMContentLoaded event listener
function getUrlFen() {
    try {
        const urlParams = new URLSearchParams(window.location.search);
        const fen = urlParams.get('fen');
        if (!fen) return null;
        
        // Decode the FEN string
        const decodedFen = decodeURIComponent(fen).trim();
        
        // Validate FEN through existing parser
        FenParser.validatePosition(decodedFen);
        
        return decodedFen;
    } catch (error) {
        console.error('FEN parsing error:', error);
        Notification.show('Invalid FEN in URL: ' + error.message, 'error');
        return null;
    }
}

// Update the DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', () => {
    const urlFen = getUrlFen();
    console.log(urlFen)
    initializeGame(urlFen);  // Existing initializeGame will handle null case
    initializeMenuHandlers();
});
</script>
</body>
</html>
